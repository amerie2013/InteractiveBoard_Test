<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…Ø®ØªØ¨Ø± Ø§Ù„Ù‡Ù†Ø¯Ø³Ø© Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠ Ø§Ù„Ø´Ø§Ù…Ù„</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    
    <style>
        body { margin: 0; padding: 0; overflow: hidden; font-family: sans-serif; background-color: #f8fafc; }
        #geometry-engine-root { height: 100vh; width: 100vw; }
        canvas { touch-action: none; }
        .sidebar-scroll { overflow-y: auto; scrollbar-width: thin; }
        .sidebar-scroll::-webkit-scrollbar { width: 6px; }
        .sidebar-scroll::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }
        .zoom-controls { position: absolute; bottom: 24px; left: 24px; display: flex; flex-direction: column; gap: 8px; z-index: 30; }
        .zoom-btn { width: 44px; height: 44px; background: white; border: 1px solid #e2e8f0; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: bold; color: #475569; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1); transition: all 0.2s; }
        .zoom-btn:hover { background: #f1f5f9; transform: translateY(-1px); }
        .embed-hidden { display: none !important; }
    </style>
</head>
<body>

<div id="geometry-engine-root"></div>

<script type="text/babel">
const { useState, useRef, useEffect, useCallback, useMemo } = React;

const App = () => {
  // Ø¯Ù…Ø¬ Ø±Ù…Ø² Ø§Ù„ÙˆØµÙˆÙ„ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ù‡Ù†Ø§
  const GITHUB_TOKEN = "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";

  const isEmbedMode = new URLSearchParams(window.location.search).get('embed') === 'true';

  const getInitialData = (key, defaultValue) => {
    const saved = localStorage.getItem(key);
    return saved ? JSON.parse(saved) : defaultValue;
  };

  const [functions, setFunctions] = useState(() => getInitialData('geo_functions', [
    { id: 'f1', expression: "y > x^2", color: '#ef4444', visible: true, thickness: 3, domainMin: '', domainMax: '', rangeMin: '', rangeMax: '' }
  ]));
  
  const [sliders, setSliders] = useState(() => getInitialData('geo_sliders', [
    { id: 's1', name: 'a', value: 1, min: -10, max: 10, step: 0.1, isAnimating: false, speed: 1, mode: 'forward', direction: 1 }
  ]));

  const [labels, setLabels] = useState(() => getInitialData('geo_labels', [
    { id: 'l1', text: "Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ØµÙ„", x: "0", y: "0", color: '#475569', visible: true, showPoint: true, rotation: "0", fontSize: "14" }
  ]));

  const [tables, setTables] = useState(() => getInitialData('geo_tables', [
    { id: 't1', name: "Ø¬Ø¯ÙˆÙ„ Ø¨ÙŠØ§Ù†Ø§Øª", visible: true, color: '#10b981', pointShape: 'circle', points: [{ x: 1, y: 1 }, { x: 2, y: 3 }] }
  ]));

  const [images, setImages] = useState([]); 
  const [showGrid, setShowGrid] = useState(true);
  const [showAxes, setShowAxes] = useState(true);
  const [showLabels, setShowLabels] = useState(true);
  const [gridStepX, setGridStepX] = useState("auto");
  const [gridStepY, setGridStepY] = useState("auto");
  const [isSidebarOpen, setIsSidebarOpen] = useState(!isEmbedMode);
  const [graphTitle, setGraphTitle] = useState("Ù…Ø®ØªØ¨Ø± Ø§Ù„Ø¯ÙˆØ§Ù„ ÙˆØ§Ù„Ø¨ÙŠØ§Ù†Ø§Øª");
  const [zoom, setZoom] = useState(40); 
  const [offset, setOffset] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const dragStart = useRef({ x: 0, y: 0 });
  const canvasRef = useRef(null);

  const gridOptions = ["auto", 0.1, 0.5, 1, 2, 5, 10, 20, 50, 100, "pi"];
  const parseStep = (val) => val === "pi" ? Math.PI : (val === "auto" ? null : parseFloat(val));
  const config = { minZoom: 2, maxZoom: 1000, gridColor: '#f1f5f9', axisColor: '#334155', labelColor: '#94a3b8' };

  const handleNewProject = () => {
    if(confirm("Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ØŸ Ø³ÙŠØªÙ… Ù…Ø³Ø­ ÙƒØ§ÙØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©.")) {
        setFunctions([]); setSliders([]); setLabels([]); setTables([]); setImages([]);
    }
  };

  const handleSaveToFile = () => {
    const data = { 
        version: "1.0",
        functions, sliders, labels, tables, graphTitle, zoom, offset,
        settings: { showGrid, showAxes, showLabels, gridStepX, gridStepY }
    };
    const blob = new Blob([JSON.stringify(data)], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `${graphTitle.replace(/\s+/g, '_')}.geolab`;
    link.click();
    URL.revokeObjectURL(url);
  };

  // --- Ø¯ÙˆØ§Ù„ Ø§Ù„Ø­ÙØ¸ ÙˆØ§Ù„ØªØ­Ù…ÙŠÙ„ Ø¹Ø¨Ø± Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… GitHub ---
  const handleSaveOnline = async () => {
    const data = { 
        version: "1.0",
        functions, sliders, labels, tables, graphTitle, zoom, offset,
        settings: { showGrid, showAxes, showLabels, gridStepX, gridStepY }
    };
    
    try {
        const response = await fetch('https://api.github.com/gists', {
            method: 'POST',
            headers: { 
                'Authorization': `token ${GITHUB_TOKEN}`, 
                'Content-Type': 'application/json' 
            },
            body: JSON.stringify({
                description: `Geometry Lab Project: ${graphTitle}`,
                public: false,
                files: { [`${graphTitle}.geolab`]: { content: JSON.stringify(data) } }
            })
        });
        const result = await response.json();
        if(result.id) {
            alert(`ØªÙ… Ø§Ù„Ø­ÙØ¸ Ø³Ø­Ø§Ø¨ÙŠØ§Ù‹ Ø¨Ù†Ø¬Ø§Ø­!\nÙ…Ø¹Ø±Ù Ø§Ù„Ù…Ù„Ù (Gist ID) Ù‡Ùˆ: ${result.id}`);
            console.log("Gist URL:", result.html_url);
        } else {
            throw new Error();
        }
    } catch (err) {
        alert("Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­ÙØ¸. ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø±Ù…Ø² Ù„Ø§ ÙŠØ²Ø§Ù„ ØµØ§Ù„Ø­Ø§Ù‹.");
    }
  };

  const handleLoadOnline = async () => {
    const gistId = prompt("Ø£Ø¯Ø®Ù„ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø³Ø­Ø§Ø¨ÙŠ (Gist ID):");
    if(!gistId) return;

    try {
        const response = await fetch(`https://api.github.com/gists/${gistId}`);
        const result = await response.json();
        const fileContent = Object.values(result.files)[0].content;
        const data = JSON.parse(fileContent);
        applyData(data);
        alert("ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ø¨Ù†Ø¬Ø§Ø­!");
    } catch (err) {
        alert("ØªØ¹Ø°Ø± Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù„Ù. ØªØ£ÙƒØ¯ Ù…Ù† ØµØ­Ø© Ø§Ù„Ù…Ø¹Ø±Ù (ID).");
    }
  };

  const applyData = (data) => {
    if(data.functions) setFunctions(data.functions);
    if(data.sliders) setSliders(data.sliders);
    if(data.labels) setLabels(data.labels);
    if(data.tables) setTables(data.tables);
    if(data.graphTitle) setGraphTitle(data.graphTitle);
    if(data.zoom) setZoom(data.zoom);
    if(data.offset) setOffset(data.offset);
    if(data.settings) {
        setShowGrid(data.settings.showGrid);
        setShowAxes(data.settings.showAxes);
        setShowLabels(data.settings.showLabels);
        setGridStepX(data.settings.gridStepX);
        setGridStepY(data.settings.gridStepY);
    }
  };

  const handleOpenFile = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (event) => {
      try { applyData(JSON.parse(event.target.result)); } 
      catch (err) { alert("Ø®Ø·Ø£: Ø§Ù„Ù…Ù„Ù ØºÙŠØ± Ù…ØªÙˆØ§ÙÙ‚."); }
    };
    reader.readAsText(file);
    e.target.value = ''; 
  };

  const resolveVal = (val, context) => {
    if (typeof val === 'number') return val;
    try { return math.evaluate(String(val).toLowerCase(), context); } 
    catch(e) { return parseFloat(val) || 0; }
  };

  const currentContext = useMemo(() => {
    const ctx = {};
    sliders.forEach(s => { ctx[s.name.toLowerCase()] = s.value; });
    return ctx;
  }, [sliders]);

  useEffect(() => {
    localStorage.setItem('geo_functions', JSON.stringify(functions));
    localStorage.setItem('geo_sliders', JSON.stringify(sliders));
    localStorage.setItem('geo_labels', JSON.stringify(labels));
    localStorage.setItem('geo_tables', JSON.stringify(tables));
  }, [functions, sliders, labels, tables]);

  useEffect(() => {
    let animationFrame;
    const animate = () => {
      setSliders(prev => prev.map(s => {
        if (!s.isAnimating) return s;
        let delta = (s.step || 0.1) * s.speed * (s.direction || 1);
        let nextValue = s.value + delta;
        let nextDirection = s.direction || 1;
        if (s.mode === 'forward') { if (nextValue > s.max) nextValue = s.min; nextDirection = 1; } 
        else if (s.mode === 'backward') { if (nextValue < s.min) nextValue = s.max; nextDirection = -1; } 
        else if (s.mode === 'pingpong') { if (nextValue > s.max) { nextValue = s.max; nextDirection = -1; } if (nextValue < s.min) { nextValue = s.min; nextDirection = 1; } }
        return { ...s, value: parseFloat(nextValue.toFixed(2)), direction: nextDirection };
      }));
      animationFrame = requestAnimationFrame(animate);
    };
    if (sliders.some(s => s.isAnimating)) animationFrame = requestAnimationFrame(animate);
    return () => cancelAnimationFrame(animationFrame);
  }, [sliders.some(s => s.isAnimating)]);

  const exportImage = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const link = document.createElement('a');
    link.download = `${graphTitle}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
  };

  const handleZoom = (delta) => {
    setZoom(prev => {
        const factor = delta > 0 ? 1.2 : 0.8;
        const newZoom = prev * factor;
        return Math.min(config.maxZoom, Math.max(config.minZoom, newZoom));
    });
  };

  const compiledFunctions = useMemo(() => {
    return functions.map(f => {
      try {
        let expr = f.expression.toLowerCase().replace(/\s+/g, '');
        let operator = '=';
        if (expr.includes('>=')) operator = '>='; else if (expr.includes('<=')) operator = '<='; else if (expr.includes('>')) operator = '>'; else if (expr.includes('<')) operator = '<'; else if (expr.includes('=')) operator = '=';
        const parts = expr.split(operator);
        const mathExpr = `(${parts[0]}) - (${parts[1]})`;
        return { ...f, node: math.parse(mathExpr), operator, context: currentContext, error: false };
      } catch (e) { return { ...f, node: null, error: true }; }
    });
  }, [functions, currentContext]);

  const handleImageUpload = (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (event) => {
        const img = new Image();
        img.src = event.target.result;
        img.onload = () => {
          setImages([...images, { id: 'img' + Date.now(), element: img, x: "0", y: "0", width: "5", rotation: "0", opacity: "1", visible: true }]);
        };
      };
      reader.readAsDataURL(file);
    }
  };

  const toScreen = (x, y, width, height) => ({ px: width / 2 + (x * zoom) + offset.x, py: height / 2 - (y * zoom) + offset.y });
  const toMath = (px, py, width, height) => ({ x: (px - width / 2 - offset.x) / zoom, y: (height / 2 - py + offset.y) / zoom });

  const getBounds = () => {
    if (!canvasRef.current) return { xMin: -10, xMax: 10, yMin: -10, yMax: 10 };
    const width = canvasRef.current.width, height = canvasRef.current.height;
    const tl = toMath(0, 0, width, height), br = toMath(width, height, width, height);
    return { xMin: tl.x, xMax: br.x, yMin: br.y, yMax: tl.y };
  };

  const drawPoint = (ctx, px, py, shape, size, color) => {
    ctx.fillStyle = color; ctx.beginPath();
    if (shape === 'square') ctx.rect(px - size, py - size, size * 2, size * 2);
    else if (shape === 'triangle') { ctx.moveTo(px, py - size); ctx.lineTo(px - size, py + size); ctx.lineTo(px + size, py + size); ctx.closePath(); }
    else ctx.arc(px, py, size, 0, Math.PI * 2);
    ctx.fill();
  };

  const draw = useCallback(() => {
    const canvas = canvasRef.current; if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const width = canvas.width = canvas.offsetWidth, height = canvas.height = canvas.offsetHeight;
    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = "white"; ctx.fillRect(0,0,width,height);
    const centerX = width / 2 + offset.x, centerY = height / 2 + offset.y;
    const b = getBounds();
    const autoStep = (zoom > 150 ? 0.5 : (zoom < 30 ? 5 : 1));
    const sX = parseStep(gridStepX) || autoStep, sY = parseStep(gridStepY) || autoStep;

    if (showGrid) {
      ctx.beginPath(); ctx.strokeStyle = config.gridColor;
      for (let x = Math.floor(b.xMin / sX) * sX; x <= b.xMax; x += sX) { const p = toScreen(x, 0, width, height); ctx.moveTo(p.px, 0); ctx.lineTo(p.px, height); }
      for (let y = Math.floor(b.yMin / sY) * sY; y <= b.yMax; y += sY) { const p = toScreen(0, y, width, height); ctx.moveTo(0, p.py); ctx.lineTo(width, p.py); }
      ctx.stroke();
    }
    if (showAxes) { ctx.beginPath(); ctx.strokeStyle = config.axisColor; ctx.lineWidth = 2; ctx.moveTo(0, centerY); ctx.lineTo(width, centerY); ctx.moveTo(centerX, 0); ctx.lineTo(centerX, height); ctx.stroke(); }
    if (showLabels) {
      ctx.fillStyle = config.labelColor; ctx.font = '10px sans-serif';
      for (let i = Math.floor(b.xMin / sX) * sX; i <= b.xMax; i += sX) { if (Math.abs(i) < 0.001) continue; const p = toScreen(i, 0, width, height); ctx.fillText(i.toFixed(1).replace('.0',''), p.px, centerY + 15); }
      for (let i = Math.floor(b.yMin / sY) * sY; i <= b.yMax; i += sY) { if (Math.abs(i) < 0.001) continue; const p = toScreen(0, i, width, height); ctx.fillText(i.toFixed(1).replace('.0',''), centerX - 15, p.py + 3); }
    }
    images.forEach(img => {
        if (!img.visible) return;
        const p = toScreen(resolveVal(img.x, currentContext), resolveVal(img.y, currentContext), width, height);
        const imgW = resolveVal(img.width, currentContext) * zoom, imgH = (img.element.height / img.element.width) * imgW;
        ctx.save(); ctx.translate(p.px, p.py); ctx.rotate(resolveVal(img.rotation, currentContext) * Math.PI / 180); ctx.globalAlpha = resolveVal(img.opacity, currentContext); ctx.drawImage(img.element, -imgW/2, -imgH/2, imgW, imgH); ctx.restore();
    });
    tables.forEach(table => { if (!table.visible) return; table.points.forEach(p => { if(p.x !== '' && p.y !== '') { const sp = toScreen(parseFloat(p.x), parseFloat(p.y), width, height); drawPoint(ctx, sp.px, sp.py, table.pointShape, 5, table.color); } }); });
    labels.forEach(lbl => {
        if (!lbl.visible) return;
        const p = toScreen(resolveVal(lbl.x, currentContext), resolveVal(lbl.y, currentContext), width, height);
        ctx.save(); ctx.translate(p.px, p.py); ctx.rotate(resolveVal(lbl.rotation, currentContext) * Math.PI / 180); ctx.fillStyle = lbl.color; ctx.font = `bold ${resolveVal(lbl.fontSize, currentContext)}px sans-serif`; ctx.textAlign = 'center'; ctx.fillText(lbl.text, 0, -12); ctx.restore();
        if (lbl.showPoint) { ctx.beginPath(); ctx.fillStyle = lbl.color; ctx.arc(p.px, p.py, 4, 0, Math.PI * 2); ctx.fill(); }
    });
    compiledFunctions.forEach(f => {
      if (!f.visible || f.error || !f.node) return;
      const code = f.node.compile(); const res = 4; const rows = Math.ceil(height / res), cols = Math.ceil(width / res);
      const gridData = new Float32Array((rows + 1) * (cols + 1));
      const dMin = f.domainMin !== '' ? parseFloat(f.domainMin) : -Infinity, dMax = f.domainMax !== '' ? parseFloat(f.domainMax) : Infinity;
      const rMin = f.rangeMin !== '' ? parseFloat(f.rangeMin) : -Infinity, rMax = f.rangeMax !== '' ? parseFloat(f.rangeMax) : Infinity;
      for (let j = 0; j <= rows; j++) { for (let i = 0; i <= cols; i++) { const m = toMath(i * res, j * res, width, height); if (m.x < dMin || m.x > dMax || m.y < rMin || m.y > rMax) { gridData[j * (cols + 1) + i] = NaN; continue; } try { gridData[j * (cols + 1) + i] = code.evaluate({ x: m.x, y: m.y, ...f.context }); } catch (e) { gridData[j * (cols + 1) + i] = NaN; } } }
      if (f.operator !== '=') { ctx.fillStyle = f.color + '33'; for (let j = 0; j < rows; j++) { for (let i = 0; i < cols; i++) { const val = gridData[j * (cols + 1) + i]; if (isNaN(val)) continue; let shouldFill = false; if ((f.operator === '>' || f.operator === '>=') && val > 0) shouldFill = true; if ((f.operator === '<' || f.operator === '<=') && val < 0) shouldFill = true; if (shouldFill) ctx.fillRect(i * res, j * res, res, res); } } }
      ctx.beginPath(); ctx.strokeStyle = f.color; ctx.lineWidth = f.thickness; if (f.operator === '>' || f.operator === '<') ctx.setLineDash([10, 5]); else ctx.setLineDash([]);
      for (let j = 0; j < rows; j++) { for (let i = 0; i < cols; i++) { const x0 = i * res, x1 = (i + 1) * res, y0 = j * res, y1 = (j + 1) * res, v0 = gridData[j * (cols + 1) + i], v1 = gridData[j * (cols + 1) + (i + 1)], v2 = gridData[(j + 1) * (cols + 1) + (i + 1)], v3 = gridData[(j + 1) * (cols + 1) + i]; if (isNaN(v0) || isNaN(v1) || isNaN(v2) || isNaN(v3)) continue; const getEdge = (valA, valB, pA, pB) => { if (valA * valB > 0) return null; const t = Math.abs(valA) / (Math.abs(valA) + Math.abs(valB)); return { x: pA.x + t * (pB.x - pA.x), y: pA.y + t * (pB.y - pA.y) }; }; const edges = [getEdge(v0,v1,{x:x0,y:y0},{x:x1,y:y0}),getEdge(v1,v2,{x:x1,y:y0},{x:x1,y:y1}),getEdge(v2,v3,{x:x1,y:y1},{x:x0,y:y1}),getEdge(v3,v0,{x:x0,y:y1},{x:x0,y:y0})].filter(e => e !== null); if (edges.length >= 2) { ctx.moveTo(edges[0].x, edges[0].y); ctx.lineTo(edges[1].x, edges[1].y); } } }
      ctx.stroke(); ctx.setLineDash([]);
    });
    if (graphTitle) { ctx.fillStyle = '#1e293b'; ctx.font = 'bold 22px sans-serif'; ctx.textAlign = 'center'; ctx.fillText(graphTitle, width / 2, 50); }
  }, [compiledFunctions, showGrid, showAxes, showLabels, gridStepX, gridStepY, zoom, offset, graphTitle, labels, tables, images, sliders, currentContext]);

  useEffect(() => { draw(); window.addEventListener('resize', draw); return () => window.removeEventListener('resize', draw); }, [draw]);

  return (
    <div className="flex h-screen w-screen bg-white overflow-hidden font-sans text-right relative" dir="rtl">
      
      <div className={`zoom-controls ${isEmbedMode ? 'embed-hidden' : ''}`}>
          <button onClick={() => handleZoom(1)} className="zoom-btn" title="Zoom In">+</button>
          <button onClick={() => handleZoom(-1)} className="zoom-btn" title="Zoom Out">âˆ’</button>
      </div>

      <button onClick={() => setIsSidebarOpen(!isSidebarOpen)} className={`absolute top-4 right-4 z-50 p-2 bg-white border border-slate-200 shadow-lg rounded-full transition-all duration-300 ${isSidebarOpen ? 'mr-80' : 'mr-0'} ${isEmbedMode ? 'embed-hidden' : ''}`}>
        <svg xmlns="http://www.w3.org/2000/svg" className={`h-6 w-6 text-slate-600 ${isSidebarOpen ? 'rotate-180' : ''}`} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" /></svg>
      </button>

      <div className={`fixed inset-y-0 right-0 w-80 bg-slate-50 border-l border-slate-200 flex flex-col sidebar-scroll p-6 space-y-6 shadow-2xl z-40 transition-transform duration-300 ${isSidebarOpen ? 'translate-x-0' : 'translate-x-full'}`}>
        <h2 className="font-bold text-slate-800 text-xl border-b pb-2">Ù…Ø®ØªØ¨Ø± Ø§Ù„Ù‡Ù†Ø¯Ø³Ø©</h2>
        
        <div className="grid grid-cols-2 gap-2">
            <button onClick={handleNewProject} className="bg-white border border-slate-300 text-[10px] p-2 rounded font-bold hover:bg-slate-100 transition-colors">ğŸ“„ Ø¬Ø¯ÙŠØ¯</button>
            <label className="bg-white border border-slate-300 text-[10px] p-2 rounded font-bold text-center cursor-pointer hover:bg-slate-100 transition-colors">ğŸ“‚ ÙØªØ­<input type="file" accept=".geolab,.json" className="hidden" onChange={handleOpenFile} /></label>
        </div>
        
        <div className="grid grid-cols-2 gap-2">
            <button onClick={handleSaveToFile} className="bg-indigo-50 border border-indigo-200 text-indigo-700 text-[10px] p-2 rounded font-bold hover:bg-indigo-100 transition-colors">ğŸ’¾ Ø­ÙØ¸ Ù„Ù„Ø¬Ù‡Ø§Ø²</button>
            <button onClick={handleSaveOnline} className="bg-sky-600 border border-sky-700 text-white text-[10px] p-2 rounded font-bold hover:bg-sky-700 transition-colors">â˜ï¸ Ø­ÙØ¸ Ø³Ø­Ø§Ø¨ÙŠ</button>
        </div>
        
        <button onClick={handleLoadOnline} className="bg-slate-800 text-white p-2 rounded font-bold text-[10px] shadow-sm hover:bg-slate-900">ğŸ”— ÙØªØ­ Ù…Ù† Ø§Ù„Ø³Ø­Ø§Ø¨Ø© (ID)</button>

        <div className="grid grid-cols-2 gap-2">
            <button onClick={() => setSliders([...sliders, { id: 's'+Date.now(), name: 'var', value: 1, min: -10, max: 10, step: 0.1, isAnimating: false, speed: 1, mode: 'forward', direction: 1 }])} className="text-[11px] bg-indigo-600 text-white p-2 rounded font-bold">+ Ù…Ù†Ø²Ù„Ù‚</button>
            <button onClick={() => setFunctions([...functions, { id: 'f'+Date.now(), expression: "y = x", color: '#3b82f6', visible: true, thickness: 3, domainMin: '', domainMax: '', rangeMin: '', rangeMax: '' }])} className="text-[11px] bg-blue-600 text-white p-2 rounded font-bold">+ Ø¯Ø§Ù„Ø©</button>
            <button onClick={() => setTables([...tables, { id: 't'+Date.now(), name: "Ø¬Ø¯ÙˆÙ„ Ø¬Ø¯ÙŠØ¯", visible: true, color: '#f59e0b', pointShape: 'circle', points: [{ x: 0, y: 0 }] }])} className="text-[11px] bg-amber-500 text-white p-2 rounded font-bold">+ Ø¬Ø¯ÙˆÙ„</button>
            <button onClick={() => setLabels([...labels, { id: 'l'+Date.now(), text: "Ù†Øµ Ø¬Ø¯ÙŠØ¯", x: "2", y: "2", color: '#059669', visible: true, showPoint: true, rotation: "0", fontSize: "14" }])} className="text-[11px] bg-emerald-600 text-white p-2 rounded font-bold">+ Ù†Øµ</button>
            <label className="text-[11px] bg-rose-500 text-white p-2 rounded font-bold text-center cursor-pointer">+ ØµÙˆØ±Ø©<input type="file" accept="image/*" className="hidden" onChange={handleImageUpload} /></label>
        </div>

        {labels.map(lbl => (
            <div key={lbl.id} className="p-3 bg-white border rounded-xl shadow-sm space-y-3">
                <div className="flex justify-between items-center text-xs font-bold border-b pb-1">
                    <div className="flex items-center gap-2">
                        <input type="color" value={lbl.color} onChange={e => setLabels(prev => prev.map(l => l.id === lbl.id ? {...l, color: e.target.value} : l))} className="w-4 h-4 border-none cursor-pointer" />
                        <span>ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù†Øµ</span>
                    </div>
                    <button onClick={() => setLabels(labels.filter(x => x.id !== lbl.id))} className="text-red-300 text-lg">Ã—</button>
                </div>
                <input type="text" className="w-full p-1 border rounded text-xs" value={lbl.text} placeholder="Ø£Ø¯Ø®Ù„ Ø§Ù„Ù†Øµ Ù‡Ù†Ø§..." onChange={e => setLabels(prev => prev.map(l => l.id === lbl.id ? {...l, text: e.target.value} : l))} />
                <div className="grid grid-cols-2 gap-2 text-[10px]">
                    <div className="flex flex-col"><label>X:</label><input type="text" className="p-1 border rounded text-center" value={lbl.x} onChange={e => setLabels(prev => prev.map(l => l.id === lbl.id ? {...l, x: e.target.value} : l))} /></div>
                    <div className="flex flex-col"><label>Y:</label><input type="text" className="p-1 border rounded text-center" value={lbl.y} onChange={e => setLabels(prev => prev.map(l => l.id === lbl.id ? {...l, y: e.target.value} : l))} /></div>
                </div>
            </div>
        ))}

        {functions.map(f => (
          <div key={f.id} className="p-3 bg-white border rounded-xl shadow-sm space-y-3">
            <div className="flex gap-2 items-center"><input type="color" value={f.color} onChange={e => setFunctions(prev => prev.map(item => item.id === f.id ? {...item, color: e.target.value} : item))} className="w-5 h-5 border-none cursor-pointer" /><input type="text" className="flex-1 p-1 border rounded text-xs font-mono" style={{ direction: 'ltr' }} value={f.expression} onChange={e => setFunctions(prev => prev.map(item => item.id === f.id ? {...item, expression: e.target.value} : item))} /><button onClick={() => setFunctions(functions.filter(x => x.id !== f.id))} className="text-red-300 text-lg">Ã—</button></div>
          </div>
        ))}

        <div className="mt-auto pt-4 border-t border-slate-200 space-y-4">
            <div className="p-2 bg-indigo-50 border border-indigo-100 rounded-lg space-y-2">
                <label className="text-[10px] font-bold text-indigo-700">ÙƒÙˆØ¯ Ø§Ù„ØªØ¶Ù…ÙŠÙ† (iframe):</label>
                <textarea readOnly className="w-full p-1 text-[9px] font-mono border rounded bg-white" rows="2" value={`<iframe src="${window.location.href.split('?')[0]}?embed=true" width="800" height="600" style="border:1px solid #ccc;"></iframe>`} />
            </div>
            <button onClick={exportImage} className="w-full py-2 bg-emerald-600 text-white rounded-lg text-xs font-bold hover:bg-emerald-700 shadow-md transition-all">ğŸ“· ØªØµØ¯ÙŠØ± ÙƒØµÙˆØ±Ø© PNG</button>
            <button onClick={() => {localStorage.clear(); window.location.reload();}} className="w-full py-2 bg-red-50 text-red-600 rounded-lg text-xs font-bold hover:bg-red-100 transition-colors">Ù…Ø³Ø­ ÙƒØ§ÙØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©</button>
        </div>
      </div>

      <div className="flex-1 relative bg-white">
        <canvas ref={canvasRef} onPointerDown={(e) => {setIsDragging(true); dragStart.current = { x: e.clientX - offset.x, y: e.clientY - offset.y };}} onPointerMove={(e) => {if (isDragging) setOffset({ x: e.clientX - dragStart.current.x, y: e.clientY - dragStart.current.y });}} onPointerUp={() => setIsDragging(false)} onWheel={(e) => setZoom(z => Math.min(config.maxZoom, Math.max(config.minZoom, z + (e.deltaY > 0 ? -z*0.1 : z*0.1))))} className="w-full h-full cursor-grab active:cursor-grabbing" />
      </div>
    </div>
  );
};

const root = ReactDOM.createRoot(document.getElementById('geometry-engine-root'));
root.render(<App />);
</script>
</body>
</html>
